> 本篇教學只是方便入門，各類別、方法、引數的用法也請參考[Java Doc](https://raymond-weng.github.io/JGame-Library-Lite/Doc/index.html)

# 基礎設定
請先將程式完整下載後，將`jGame`複製到src中。

# 遊戲初始化
> 注意：在本篇教學中所有需要撰寫的程式都請撰寫在`jGame`之外的地方

1. 建立一個main class
2. 你需要一個output，更詳細的介紹可以前往章節[Output製作](https://github.com/Raymond-Weng/JGame-Library-Lite/blob/main/教學.md#Output製作)
3. 建立一個屬於Game(`jGame.main.Game`)的Object，更詳細的介紹可以前往章節[Game建立](https://github.com/Raymond-Weng/JGame-Library-Lite/blob/main/教學.md#Game建立)
4. 將Game初始化，例如以下程式片段
```java
import jGame.main.Game;

public class Tutorial {
    Game game;

    public static void main(String[] args) {
        //...
        game.build();
    }
}
```
即可初始化物件。  
5. 讓遊戲開始運行，例如以下程式片段
```java
import jGame.main.Game;

public class Tutorial {
    Game game;

    public static void main(String[] args) {
        //...
        game.run();
    }
}
```

# Output製作
在製作Output時，你有幾個選擇

- 使用已經寫好的Frame，建立一個視窗
- 建立一個自己寫的class，並使用他

以下方法我都會寫成次標題

### 使用Library的Output
在這個Game Library中，已經有做出一個可以正常使用的視窗Frame(`jGame.output.Frame`)，可以直接使用，方法如下：
1. Frame的物件建立使用`Builder`，可建立一個Builder物件並使用`build()`取得Frame，範例程式如下
```java
import jGame.output.Frame;

public class Tutorial {
    public static void main(String[] args) {
        Frame frame = new Frame.Builder()   //建立一個Frame Builder
                .build();   //產生Frame
    }
}
```
但是這個程式執行完會丟出例外，因為我們沒有足夠的設定，讓我們進入下一步
2. 在使用`build()`前，需要設定引數，例如
```java
import jGame.output.Frame;

public class Tutorial {
    public static void main(String[] args) {
        Frame frame = new Frame.Builder()
                .setSize(new Size(1000, 800))
                .build();
    }
}
```
有許多的引數可以設定，包含
- `setDefaultCloseOperation(int defaultCloseOperation)`
- `setFrameTitle(String title)`
- `setIcon(Image icon)`
- `setKeyListener(KeyListener keyListener)`
- `setMouseListener(MouseListener mouseListener)`
- `setMouseMotionListener(MouseMotionListener mouseMotionListener)`
- `setNumBufferStrategy(int numBufferStrategy)`
- `setSize(Size size)`
- `setFullScreen(boolean fullScreen)`

並且可以連接許多設定，例如
```java
import jGame.output.Frame;

public class Tutorial {
    public static void main(String[] args) {
        Frame frame = new Frame.Builder()
                .setSize(new Size(1000, 800))
                .setFrameTitle("My new Game")
                .build();
    }
}
```
其中大部分的引數是選填的，其中必填的選項有這些：
- `setSize(Size size)`

各引數的介紹可以參考[Java Doc](https://raymond-weng.github.io/JGame-Library-Lite/Doc/index.html)，打開後可從左邊的class列表選擇`Frame.Builder`即可得到詳細資料。

### 自己製作Output
自己製作Output時，需要建立一個class並且實作介面`Output`(`jGame.output.Output`)，例如以下程式。
```java
import jGame.core.Size;
import jGame.output.Output;

import java.awt.*;

public class OutputTutorial implements Output {
    @Override
    public Graphics getGraphics() {
        return null;
    }

    @Override
    public void show() {

    }

    @Override
    public Size getSize() {
        return null;
    }
}
```
其中有幾個方法需要實作
1. `getGraphics()`  
請回傳該輸出元件的Graphics(`java.awt.Graphics`)物件，例如`JFrame`就要回傳`frame.getGraphics()`
2. `show()`  
這個方法是元件具有BufferStrategy或其他類似功能時需要用到，表示已經在Graphics畫好畫面，可以顯示了。
3. `getSize`  
這個方法需要以Size(`jGame.core.Size`)回傳顯示區域的大小，例如JFrame就要回傳視窗大小。

實作完成後，即可在Main class中建立一個屬於該類別的物件備用，準備進入下一步驟。

# Game建立
> 在繼續下去之前，請確認`Output`已經完成

建立一個Game和建立一個Frame方法類似，例如：
```java
import jGame.main.Game;

public class Tutorial {
    public static void main(String[] args) {
        //...
        Game game = new Game.Builder()  //建立Builder
                .build();   //取得Game
    }
}
```
建立Builder並使用`build()`得到Game物件，但是這樣會丟出Exception，因為他需要跟多東西。可以輸入的引數有：
- `setBackgroundColor(Color backgroundColor)`
- `setCamera(Camera camera)`
- `setDebug(boolean debug)`
- `setFontSize(int fontSize)`
- `setGameStartDelay(int gameStartDelay)`
- `setLoadingImage(java.awt.Image loadingImage) `
- `setLoadingTimeOut(int loadingTimeOut)`
- `setOnlyRenderAfterUpdate(boolean ONLY_RENDER_AFTER_UPDATE)`
- `setOutput(Output output)`
- `setRender(Render render)`
- `setThreadCount(int threadCount)`
- `setUpdate(Update update)`

其中必填的項目有：
- `setOutput(Output output)`
- `setRender(Render render)`
- `setUpdate(Update update)`

設定時可以全部連起來，例如：
```java
import jGame.main.Game;
import jGame.output.Output;
import jGame.loop.render.Render;
import jGame.loop.update.Update;

public class Tutorial {
    public static void main(String[] args) {
        Output output;
        Render render;
        Update update;
        
        //...
        
        Game game = new Game.Builder()
                .setOutput(output)
                .setRender(render)
                .setUpdate(update)
                .build();
    }
}
```
詳細的引數介紹也請參考[Java Doc](https://raymond-weng.github.io/JGame-Library-Lite/Doc/index.html)，打開後可從左邊的class列表選擇`Game.Builder`即可得到詳細資料。  

其中一些class獨特的使用方式，可以繼續看下面的介紹，或是按右上角三條槓槓看目錄。


# 開始撰寫遊戲邏輯
### 讓畫面出現東西
在這個Library，所有在畫面上出現的物品都是`GameObject`，所以就從他開始！  
要建立一個GameObject，首先要建立一個GameObject的子類別，如下

```java
import jGame.core.Position;
import jGame.core.Size;
import jGame.gameObject.GameObject;
import jGame.gameObject.hitbox.Hitbox;

import java.awt.*;

public class GameObjectTutorial extends GameObject {
    @Override
    public void update() {

    }

    @Override
    public Image render() {
        return null;
    }

    @Override
    public Position getPosition() {
        return null;
    }

    @Override
    public Hitbox getHitbox() {
        return null;
    }

    @Override
    public Size getSize() {
        return null;
    }
}
```
其中有許多需要實作的方法，我會一一解釋：  
1. `update()`是用來更新物件的狀態，例如改變位置、判斷碰撞等
2. `render()`需要提供物件的照片給中心程式。請注意，不要再提供的照片中處理座標，也就是將物件畫在回傳照片的最左上角
3. `getPosition()`會需要回傳一個Position物件，請回傳物件的實際中心位置
4. `getHitbox()`不一定要實作，但是如果有用到HitboxTracker或是其他物件需要存取他的碰撞箱記得要進行實作
5. `getSize()`一定要被實作，其目的為計算物件是否在畫面中  

最後要將這個Object加入遊戲中（否則他只是存在，並沒有人會知道要用他），利用`Game.addObject(GameObject gameObject, int priority)`(un-static)加入，例如
```java
import jGame.gameObject.GameObject;
import jGame.main.Game;

public class Tutorial {
    public static void main(String[] args) {
        Game game;
        GameObject gameObject;
        //set up the game and the game object
        game.addObject(gameObject, 1);
    }
}
```
在第二個輸入是一個int「優先度」，數字小的物件會被數字大的蓋過去。

### 碰撞箱
碰撞箱顧名思義就是指碰撞的箱子，他會判斷兩個箱子是否有接觸，飯用於遊戲中，做一個「是否兩物件有接觸」的判斷。
通常，碰撞箱不會完整包覆物件，而是包覆物件的一部分，以免碰撞箱大於角色圖形的大小。

現在開始教紹幾個可用的碰撞箱類型
1. 矩形碰撞
矩形碰撞已經實作在`Hitbox<Rectangle>`(`gameObject.hitbox.Hitbox<gameObject.hitbox.hitboxShape.Rectangle>`)中了，可以直接建立一個新物件。

```java
import jGame.core.Position;
import jGame.core.Size;
import jGame.gameObject.hitbox.Hitbox;
import jGame.gameObject.hitbox.hitboxShape.Rectangle;

public class Tutorial {
    public static void main(String[] args) {
        Hitbox<Rectangle> hitbox = new Hitbox<>(
                new Rectangle(new Position(0, 0),
                        new Size(50, 50)
                )
        );
    }
}
```
這樣我們就得到一個Hitbox，如果要判斷是否碰撞，要這樣：
```java
import jGame.core.Position;
import jGame.core.Size;
import jGame.gameObject.hitbox.Hitbox;
import jGame.gameObject.hitbox.hitboxShape.Rectangle;

public class Tutorial {
    public static void main(String[] args) {
        Hitbox<Rectangle> hitbox1 = new Hitbox<>(
                new Rectangle(new Position(0, 0),
                        new Size(50, 50)
                )
        );
        Hitbox<Rectangle> hitbox2 = new Hitbox<>(
                new Rectangle(new Position(20, 0),
                        new Size(50, 50)
                )
        );
        
        System.out.println(hitbox1.isHit(hitbox2));
    }
}
```
這樣就可以判斷兩個碰撞箱是否有碰撞。

### 定時呼叫的Timer
需要製作定期執行的事項的事項的時後，可以透過Timer註冊。  
例如
```java
import jGame.loop.timer.Timer;

public class TimerTutorial extends Timer {
    public Tutorial(int maxUps, double updateRateSecond) {
        super(maxUps, updateRateSecond);
    }

    @Override
    public void action() {
        //things to do
    }
}
```
接著利用`Game.addTimer(Timer timer, int priority)`加入，如同Game Object
```java
import jGame.loop.timer.Timer;
import jGame.main.Game;

public class Tutorial {
    public static void main(String[] args) {
        Game game;
        Timer timer;
        //set up the game and the timer
        game.addTimer(timer, 1);
    }
}
```
在第二個輸入是一個int「優先度」，代表會在第幾個執行續被執行（會被執行在`priorty-1`個執行續），請注意不要超過起初`Game.Builder`的設定值(`setThreadCount(int threadCount) - 1`)。  
加入後，會考量到updateRateSecond，如果距離上次啟動的時間超過這個時間（以秒為單位）便會執行。  
而第一個int「最大UPS」是指一秒最多可以執行幾次，如果要設為無上限可以設為`-1`。

### 多個執行續

# Debug

# Classes介紹
以下有需多class的用法，可以查看目錄進行跳轉

### Render
Render有兩種建立方式，

### Camera

### Update

### Position

### Size

### Vector